/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from "@tanstack/react-query";
import {
  useBookingContext,
  type BookingContext,
  queryKeyFn,
} from "./bookingContext";
import { deepMerge } from "./bookingUtils";
import type * as Fetcher from "./bookingFetcher";
import { bookingFetch } from "./bookingFetcher";
import type * as Schemas from "./bookingSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type PublicGetHostsError = Fetcher.ErrorWrapper<undefined>;

export type PublicGetHostsResponse = Schemas.HostDTO12[];

export type PublicGetHostsVariables = BookingContext["fetcherOptions"];

/**
 * Get list of all available hosts
 */
export const fetchPublicGetHosts = (
  variables: PublicGetHostsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    PublicGetHostsResponse,
    PublicGetHostsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api//hosts", method: "get", ...variables, signal });

/**
 * Get list of all available hosts
 */
export function publicGetHostsQuery(variables: PublicGetHostsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<PublicGetHostsResponse>;
};

export function publicGetHostsQuery(
  variables: PublicGetHostsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<PublicGetHostsResponse>)
    | reactQuery.SkipToken;
};

export function publicGetHostsQuery(
  variables: PublicGetHostsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api//hosts",
      operationId: "publicGetHosts",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchPublicGetHosts(variables, signal),
  };
}

/**
 * Get list of all available hosts
 */
export const useSuspensePublicGetHosts = <TData = PublicGetHostsResponse>(
  variables: PublicGetHostsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      PublicGetHostsResponse,
      PublicGetHostsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    PublicGetHostsResponse,
    PublicGetHostsError,
    TData
  >({
    ...publicGetHostsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get list of all available hosts
 */
export const usePublicGetHosts = <TData = PublicGetHostsResponse>(
  variables: PublicGetHostsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      PublicGetHostsResponse,
      PublicGetHostsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<
    PublicGetHostsResponse,
    PublicGetHostsError,
    TData
  >({
    ...publicGetHostsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PublicGetHostByIdPathParams = {
  id: string;
};

export type PublicGetHostByIdError = Fetcher.ErrorWrapper<undefined>;

export type PublicGetHostByIdVariables = {
  pathParams: PublicGetHostByIdPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Each user of the system can get information about the host
 */
export const fetchPublicGetHostById = (
  variables: PublicGetHostByIdVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.HostDTO12,
    PublicGetHostByIdError,
    undefined,
    {},
    {},
    PublicGetHostByIdPathParams
  >({ url: "/api/hosts/{id}", method: "get", ...variables, signal });

/**
 * Each user of the system can get information about the host
 */
export function publicGetHostByIdQuery(variables: PublicGetHostByIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.HostDTO12>;
};

export function publicGetHostByIdQuery(
  variables: PublicGetHostByIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.HostDTO12>)
    | reactQuery.SkipToken;
};

export function publicGetHostByIdQuery(
  variables: PublicGetHostByIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/hosts/{id}",
      operationId: "publicGetHostById",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchPublicGetHostById(variables, signal),
  };
}

/**
 * Each user of the system can get information about the host
 */
export const useSuspensePublicGetHostById = <TData = Schemas.HostDTO12>(
  variables: PublicGetHostByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.HostDTO12,
      PublicGetHostByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.HostDTO12,
    PublicGetHostByIdError,
    TData
  >({
    ...publicGetHostByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Each user of the system can get information about the host
 */
export const usePublicGetHostById = <TData = Schemas.HostDTO12>(
  variables: PublicGetHostByIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.HostDTO12,
      PublicGetHostByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<Schemas.HostDTO12, PublicGetHostByIdError, TData>({
    ...publicGetHostByIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PublicGetHostBookingsPathParams = {
  /**
   * Host ID
   */
  id: string;
};

export type PublicGetHostBookingsQueryParams = {
  /**
   * Sort direction for bookings
   *
   * @default ASC
   */
  sortDirection?: "DESC" | "ASC";
};

export type PublicGetHostBookingsError = Fetcher.ErrorWrapper<undefined>;

export type PublicGetHostBookingsResponse = Schemas.BookingDTO711[];

export type PublicGetHostBookingsVariables = {
  pathParams: PublicGetHostBookingsPathParams;
  queryParams?: PublicGetHostBookingsQueryParams;
} & BookingContext["fetcherOptions"];

/**
 * Get host's bookings from now until the host's forward booking period. Shows occupied time slots for planning appointments.
 */
export const fetchPublicGetHostBookings = (
  variables: PublicGetHostBookingsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    PublicGetHostBookingsResponse,
    PublicGetHostBookingsError,
    undefined,
    {},
    PublicGetHostBookingsQueryParams,
    PublicGetHostBookingsPathParams
  >({ url: "/api/hosts/{id}/bookings", method: "get", ...variables, signal });

/**
 * Get host's bookings from now until the host's forward booking period. Shows occupied time slots for planning appointments.
 */
export function publicGetHostBookingsQuery(
  variables: PublicGetHostBookingsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<PublicGetHostBookingsResponse>;
};

export function publicGetHostBookingsQuery(
  variables: PublicGetHostBookingsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<PublicGetHostBookingsResponse>)
    | reactQuery.SkipToken;
};

export function publicGetHostBookingsQuery(
  variables: PublicGetHostBookingsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/hosts/{id}/bookings",
      operationId: "publicGetHostBookings",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchPublicGetHostBookings(variables, signal),
  };
}

/**
 * Get host's bookings from now until the host's forward booking period. Shows occupied time slots for planning appointments.
 */
export const useSuspensePublicGetHostBookings = <
  TData = PublicGetHostBookingsResponse,
>(
  variables: PublicGetHostBookingsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      PublicGetHostBookingsResponse,
      PublicGetHostBookingsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    PublicGetHostBookingsResponse,
    PublicGetHostBookingsError,
    TData
  >({
    ...publicGetHostBookingsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get host's bookings from now until the host's forward booking period. Shows occupied time slots for planning appointments.
 */
export const usePublicGetHostBookings = <TData = PublicGetHostBookingsResponse>(
  variables: PublicGetHostBookingsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      PublicGetHostBookingsResponse,
      PublicGetHostBookingsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<
    PublicGetHostBookingsResponse,
    PublicGetHostBookingsError,
    TData
  >({
    ...publicGetHostBookingsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AuthRegisterError = Fetcher.ErrorWrapper<undefined>;

export type AuthRegisterVariables = {
  body: Schemas.CreateUserDTO;
} & BookingContext["fetcherOptions"];

/**
 * Registering a new user in the system
 */
export const fetchAuthRegister = (
  variables: AuthRegisterVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UserLoggedInDTO,
    AuthRegisterError,
    Schemas.CreateUserDTO,
    {},
    {},
    {}
  >({ url: "/api/auth/register", method: "post", ...variables, signal });

/**
 * Registering a new user in the system
 */
export const useAuthRegister = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserLoggedInDTO,
      AuthRegisterError,
      AuthRegisterVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.UserLoggedInDTO,
    AuthRegisterError,
    AuthRegisterVariables
  >({
    mutationFn: (variables: AuthRegisterVariables) =>
      fetchAuthRegister(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AuthLoginError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: {
    /**
     * @example Invalid login or password
     */
    error?: string;
  };
}>;

export type AuthLoginVariables = {
  body: Schemas.AuthUserDTO;
} & BookingContext["fetcherOptions"];

/**
 * Authenticate user and receive JWT token.
 *
 * **Important**: When using the returned token in other endpoints:
 * - Copy the `access_token` from the response
 * - Use it directly in the Authorization field (do not add 'Bearer ' prefix)
 * - Example: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`
 */
export const fetchAuthLogin = (
  variables: AuthLoginVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UserLoggedInDTO,
    AuthLoginError,
    Schemas.AuthUserDTO,
    {},
    {},
    {}
  >({ url: "/api/auth/login", method: "post", ...variables, signal });

/**
 * Authenticate user and receive JWT token.
 *
 * **Important**: When using the returned token in other endpoints:
 * - Copy the `access_token` from the response
 * - Use it directly in the Authorization field (do not add 'Bearer ' prefix)
 * - Example: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`
 */
export const useAuthLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserLoggedInDTO,
      AuthLoginError,
      AuthLoginVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.UserLoggedInDTO,
    AuthLoginError,
    AuthLoginVariables
  >({
    mutationFn: (variables: AuthLoginVariables) =>
      fetchAuthLogin(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ClientsGetClientError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: {
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 403;
      payload: {
        /**
         * @example Access denied
         */
        error?: string;
      };
    }
>;

export type ClientsGetClientVariables = BookingContext["fetcherOptions"];

/**
 * Get current client information
 */
export const fetchClientsGetClient = (
  variables: ClientsGetClientVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.ClientDTO2,
    ClientsGetClientError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/clients/me", method: "get", ...variables, signal });

/**
 * Get current client information
 */
export function clientsGetClientQuery(variables: ClientsGetClientVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ClientDTO2>;
};

export function clientsGetClientQuery(
  variables: ClientsGetClientVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ClientDTO2>)
    | reactQuery.SkipToken;
};

export function clientsGetClientQuery(
  variables: ClientsGetClientVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/clients/me",
      operationId: "clientsGetClient",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchClientsGetClient(variables, signal),
  };
}

/**
 * Get current client information
 */
export const useSuspenseClientsGetClient = <TData = Schemas.ClientDTO2>(
  variables: ClientsGetClientVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ClientDTO2,
      ClientsGetClientError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.ClientDTO2,
    ClientsGetClientError,
    TData
  >({
    ...clientsGetClientQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get current client information
 */
export const useClientsGetClient = <TData = Schemas.ClientDTO2>(
  variables: ClientsGetClientVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ClientDTO2,
      ClientsGetClientError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<Schemas.ClientDTO2, ClientsGetClientError, TData>({
    ...clientsGetClientQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ClientsUpdateClientError = Fetcher.ErrorWrapper<undefined>;

export type ClientsUpdateClientVariables = {
  body?: Schemas.UpdateClientDTO5;
} & BookingContext["fetcherOptions"];

/**
 * Update current client information
 */
export const fetchClientsUpdateClient = (
  variables: ClientsUpdateClientVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UserUpdatedDTO,
    ClientsUpdateClientError,
    Schemas.UpdateClientDTO5,
    {},
    {},
    {}
  >({ url: "/api/clients/me", method: "patch", ...variables, signal });

/**
 * Update current client information
 */
export const useClientsUpdateClient = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserUpdatedDTO,
      ClientsUpdateClientError,
      ClientsUpdateClientVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.UserUpdatedDTO,
    ClientsUpdateClientError,
    ClientsUpdateClientVariables
  >({
    mutationFn: (variables: ClientsUpdateClientVariables) =>
      fetchClientsUpdateClient(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ClientsDeleteClientError = Fetcher.ErrorWrapper<undefined>;

export type ClientsDeleteClientVariables = BookingContext["fetcherOptions"];

/**
 * Mark current client as deleted from the system
 */
export const fetchClientsDeleteClient = (
  variables: ClientsDeleteClientVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UsedDeletedDTO,
    ClientsDeleteClientError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/clients/me", method: "delete", ...variables, signal });

/**
 * Mark current client as deleted from the system
 */
export const useClientsDeleteClient = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UsedDeletedDTO,
      ClientsDeleteClientError,
      ClientsDeleteClientVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.UsedDeletedDTO,
    ClientsDeleteClientError,
    ClientsDeleteClientVariables
  >({
    mutationFn: (variables: ClientsDeleteClientVariables) =>
      fetchClientsDeleteClient(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ClientsGetBookingsQueryParams = {
  /**
   * Sort direction for results
   *
   * @default ASC
   */
  sortDirection?: "ASC" | "DESC";
  /**
   * Property to sort by
   *
   * @default fromDateTime
   */
  sortProperty?: string;
  /**
   * Filter bookings that start after this time (ISO8601).
   *
   * @format date-time
   */
  fromDateTime?: string;
  /**
   * Filter bookings that end before this time (ISO8601).
   *
   * @format date-time
   */
  toDateTime?: string;
};

export type ClientsGetBookingsError = Fetcher.ErrorWrapper<undefined>;

export type ClientsGetBookingsResponse = Schemas.BookingDTO1[];

export type ClientsGetBookingsVariables = {
  queryParams?: ClientsGetBookingsQueryParams;
} & BookingContext["fetcherOptions"];

/**
 * Get current client's bookings with filtering and sorting
 */
export const fetchClientsGetBookings = (
  variables: ClientsGetBookingsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    ClientsGetBookingsResponse,
    ClientsGetBookingsError,
    undefined,
    {},
    ClientsGetBookingsQueryParams,
    {}
  >({ url: "/api/clients/me/bookings", method: "get", ...variables, signal });

/**
 * Get current client's bookings with filtering and sorting
 */
export function clientsGetBookingsQuery(
  variables: ClientsGetBookingsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<ClientsGetBookingsResponse>;
};

export function clientsGetBookingsQuery(
  variables: ClientsGetBookingsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<ClientsGetBookingsResponse>)
    | reactQuery.SkipToken;
};

export function clientsGetBookingsQuery(
  variables: ClientsGetBookingsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/clients/me/bookings",
      operationId: "clientsGetBookings",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchClientsGetBookings(variables, signal),
  };
}

/**
 * Get current client's bookings with filtering and sorting
 */
export const useSuspenseClientsGetBookings = <
  TData = ClientsGetBookingsResponse,
>(
  variables: ClientsGetBookingsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ClientsGetBookingsResponse,
      ClientsGetBookingsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    ClientsGetBookingsResponse,
    ClientsGetBookingsError,
    TData
  >({
    ...clientsGetBookingsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get current client's bookings with filtering and sorting
 */
export const useClientsGetBookings = <TData = ClientsGetBookingsResponse>(
  variables: ClientsGetBookingsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ClientsGetBookingsResponse,
      ClientsGetBookingsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<
    ClientsGetBookingsResponse,
    ClientsGetBookingsError,
    TData
  >({
    ...clientsGetBookingsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ClientsCreateBookingError = Fetcher.ErrorWrapper<undefined>;

export type ClientsCreateBookingVariables = {
  body: Schemas.CreateBookingDTO3;
} & BookingContext["fetcherOptions"];

/**
 * Create a new booking for current client
 */
export const fetchClientsCreateBooking = (
  variables: ClientsCreateBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingCreatedDTO,
    ClientsCreateBookingError,
    Schemas.CreateBookingDTO3,
    {},
    {},
    {}
  >({ url: "/api/clients/me/bookings", method: "post", ...variables, signal });

/**
 * Create a new booking for current client
 */
export const useClientsCreateBooking = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BookingCreatedDTO,
      ClientsCreateBookingError,
      ClientsCreateBookingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.BookingCreatedDTO,
    ClientsCreateBookingError,
    ClientsCreateBookingVariables
  >({
    mutationFn: (variables: ClientsCreateBookingVariables) =>
      fetchClientsCreateBooking(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ClientsGetBookingByIdPathParams = {
  /**
   * ID of the booking to retrieve
   */
  bookingId: string;
};

export type ClientsGetBookingByIdError = Fetcher.ErrorWrapper<undefined>;

export type ClientsGetBookingByIdVariables = {
  pathParams: ClientsGetBookingByIdPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Get specific booking by ID for current client
 */
export const fetchClientsGetBookingById = (
  variables: ClientsGetBookingByIdVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingDTO1,
    ClientsGetBookingByIdError,
    undefined,
    {},
    {},
    ClientsGetBookingByIdPathParams
  >({
    url: "/api/clients/me/bookings/{bookingId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get specific booking by ID for current client
 */
export function clientsGetBookingByIdQuery(
  variables: ClientsGetBookingByIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.BookingDTO1>;
};

export function clientsGetBookingByIdQuery(
  variables: ClientsGetBookingByIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.BookingDTO1>)
    | reactQuery.SkipToken;
};

export function clientsGetBookingByIdQuery(
  variables: ClientsGetBookingByIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/clients/me/bookings/{bookingId}",
      operationId: "clientsGetBookingById",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchClientsGetBookingById(variables, signal),
  };
}

/**
 * Get specific booking by ID for current client
 */
export const useSuspenseClientsGetBookingById = <TData = Schemas.BookingDTO1>(
  variables: ClientsGetBookingByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.BookingDTO1,
      ClientsGetBookingByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.BookingDTO1,
    ClientsGetBookingByIdError,
    TData
  >({
    ...clientsGetBookingByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get specific booking by ID for current client
 */
export const useClientsGetBookingById = <TData = Schemas.BookingDTO1>(
  variables: ClientsGetBookingByIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.BookingDTO1,
      ClientsGetBookingByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<
    Schemas.BookingDTO1,
    ClientsGetBookingByIdError,
    TData
  >({
    ...clientsGetBookingByIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ClientsUpdateBookingPathParams = {
  /**
   * ID of the booking to update
   */
  bookingId: string;
};

export type ClientsUpdateBookingError = Fetcher.ErrorWrapper<undefined>;

export type ClientsUpdateBookingVariables = {
  body?: Schemas.UpdateBookingDTO4;
  pathParams: ClientsUpdateBookingPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Update specific booking for current client
 */
export const fetchClientsUpdateBooking = (
  variables: ClientsUpdateBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingUpdatedDTO,
    ClientsUpdateBookingError,
    Schemas.UpdateBookingDTO4,
    {},
    {},
    ClientsUpdateBookingPathParams
  >({
    url: "/api/clients/me/bookings/{bookingId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update specific booking for current client
 */
export const useClientsUpdateBooking = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BookingUpdatedDTO,
      ClientsUpdateBookingError,
      ClientsUpdateBookingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.BookingUpdatedDTO,
    ClientsUpdateBookingError,
    ClientsUpdateBookingVariables
  >({
    mutationFn: (variables: ClientsUpdateBookingVariables) =>
      fetchClientsUpdateBooking(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ClientsCancelBookingPathParams = {
  /**
   * ID of the booking to cancel
   */
  bookingId: string;
};

export type ClientsCancelBookingError = Fetcher.ErrorWrapper<undefined>;

export type ClientsCancelBookingVariables = {
  pathParams: ClientsCancelBookingPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Cancel (soft delete) specific booking for current client
 */
export const fetchClientsCancelBooking = (
  variables: ClientsCancelBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingUpdatedDTO,
    ClientsCancelBookingError,
    undefined,
    {},
    {},
    ClientsCancelBookingPathParams
  >({
    url: "/api/clients/me/bookings/{bookingId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Cancel (soft delete) specific booking for current client
 */
export const useClientsCancelBooking = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BookingUpdatedDTO,
      ClientsCancelBookingError,
      ClientsCancelBookingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.BookingUpdatedDTO,
    ClientsCancelBookingError,
    ClientsCancelBookingVariables
  >({
    mutationFn: (variables: ClientsCancelBookingVariables) =>
      fetchClientsCancelBooking(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type HostsGetMeError = Fetcher.ErrorWrapper<undefined>;

export type HostsGetMeVariables = BookingContext["fetcherOptions"];

/**
 * Get information about the current host
 */
export const fetchHostsGetMe = (
  variables: HostsGetMeVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<Schemas.HostDTO6, HostsGetMeError, undefined, {}, {}, {}>({
    url: "/api/hosts/me",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get information about the current host
 */
export function hostsGetMeQuery(variables: HostsGetMeVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.HostDTO6>;
};

export function hostsGetMeQuery(
  variables: HostsGetMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.HostDTO6>)
    | reactQuery.SkipToken;
};

export function hostsGetMeQuery(
  variables: HostsGetMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/hosts/me",
      operationId: "hostsGetMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchHostsGetMe(variables, signal),
  };
}

/**
 * Get information about the current host
 */
export const useSuspenseHostsGetMe = <TData = Schemas.HostDTO6>(
  variables: HostsGetMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.HostDTO6, HostsGetMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<Schemas.HostDTO6, HostsGetMeError, TData>({
    ...hostsGetMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get information about the current host
 */
export const useHostsGetMe = <TData = Schemas.HostDTO6>(
  variables: HostsGetMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.HostDTO6, HostsGetMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<Schemas.HostDTO6, HostsGetMeError, TData>({
    ...hostsGetMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type HostsDeleteMeError = Fetcher.ErrorWrapper<undefined>;

export type HostsDeleteMeVariables = BookingContext["fetcherOptions"];

/**
 * Mark host as deleted
 */
export const fetchHostsDeleteMe = (
  variables: HostsDeleteMeVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UsedDeletedDTO,
    HostsDeleteMeError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/hosts/me", method: "delete", ...variables, signal });

/**
 * Mark host as deleted
 */
export const useHostsDeleteMe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UsedDeletedDTO,
      HostsDeleteMeError,
      HostsDeleteMeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.UsedDeletedDTO,
    HostsDeleteMeError,
    HostsDeleteMeVariables
  >({
    mutationFn: (variables: HostsDeleteMeVariables) =>
      fetchHostsDeleteMe(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type HostsUpdateMeError = Fetcher.ErrorWrapper<undefined>;

export type HostsUpdateMeVariables = {
  body?: Schemas.UpdateHostDTO10;
} & BookingContext["fetcherOptions"];

/**
 * Update host params
 */
export const fetchHostsUpdateMe = (
  variables: HostsUpdateMeVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UserUpdatedDTO,
    HostsUpdateMeError,
    Schemas.UpdateHostDTO10,
    {},
    {},
    {}
  >({ url: "/api/hosts/me", method: "patch", ...variables, signal });

/**
 * Update host params
 */
export const useHostsUpdateMe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserUpdatedDTO,
      HostsUpdateMeError,
      HostsUpdateMeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.UserUpdatedDTO,
    HostsUpdateMeError,
    HostsUpdateMeVariables
  >({
    mutationFn: (variables: HostsUpdateMeVariables) =>
      fetchHostsUpdateMe(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type HostsCreateBookingError = Fetcher.ErrorWrapper<undefined>;

export type HostsCreateBookingVariables = {
  body: Schemas.CreateBookingDTO8;
} & BookingContext["fetcherOptions"];

/**
 * Create a new booking as a host (administrative function).
 *
 * **Important:** The hostId in the request body will be IGNORED and automatically
 * set to the current authenticated user's ID. This is an administrative endpoint
 * where hosts create bookings for their clients.
 *
 * **Use cases:**
 * - Medical receptionist booking patient appointments
 * - Service provider scheduling client meetings
 * - Host creating appointments for existing clients
 *
 * **Note:** The hostId field is required in the request body for DTO validation,
 * but its value is overridden by the current user's ID in the implementation.
 */
export const fetchHostsCreateBooking = (
  variables: HostsCreateBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingCreatedDTO,
    HostsCreateBookingError,
    Schemas.CreateBookingDTO8,
    {},
    {},
    {}
  >({ url: "/api/hosts/me/bookings", method: "post", ...variables, signal });

/**
 * Create a new booking as a host (administrative function).
 *
 * **Important:** The hostId in the request body will be IGNORED and automatically
 * set to the current authenticated user's ID. This is an administrative endpoint
 * where hosts create bookings for their clients.
 *
 * **Use cases:**
 * - Medical receptionist booking patient appointments
 * - Service provider scheduling client meetings
 * - Host creating appointments for existing clients
 *
 * **Note:** The hostId field is required in the request body for DTO validation,
 * but its value is overridden by the current user's ID in the implementation.
 */
export const useHostsCreateBooking = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BookingCreatedDTO,
      HostsCreateBookingError,
      HostsCreateBookingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.BookingCreatedDTO,
    HostsCreateBookingError,
    HostsCreateBookingVariables
  >({
    mutationFn: (variables: HostsCreateBookingVariables) =>
      fetchHostsCreateBooking(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type HostsGetMyBookingsQueryParams = {
  /**
   * Filter by client ID
   */
  clientId?: string;
  /**
   * Sort direction
   *
   * @default DESC
   */
  sortDirection?: "DESC" | "ASC";
  /**
   * Property to sort by
   *
   * @default fromDateTime
   */
  sortProperty?: "fromDateTime" | "toDateTime";
  /**
   * Filter bookings from this date-time (ISO8601)
   *
   * @format date-time
   */
  fromDateTime?: string;
  /**
   * Filter bookings until this date-time (ISO8601)
   *
   * @format date-time
   */
  toDateTime?: string;
};

export type HostsGetMyBookingsError = Fetcher.ErrorWrapper<undefined>;

export type HostsGetMyBookingsResponse = Schemas.BookingDTO7[];

export type HostsGetMyBookingsVariables = {
  queryParams?: HostsGetMyBookingsQueryParams;
} & BookingContext["fetcherOptions"];

/**
 * Get all bookings for the current host with optional filtering and sorting
 */
export const fetchHostsGetMyBookings = (
  variables: HostsGetMyBookingsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    HostsGetMyBookingsResponse,
    HostsGetMyBookingsError,
    undefined,
    {},
    HostsGetMyBookingsQueryParams,
    {}
  >({ url: "/api/hosts/me/bookings", method: "get", ...variables, signal });

/**
 * Get all bookings for the current host with optional filtering and sorting
 */
export function hostsGetMyBookingsQuery(
  variables: HostsGetMyBookingsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<HostsGetMyBookingsResponse>;
};

export function hostsGetMyBookingsQuery(
  variables: HostsGetMyBookingsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<HostsGetMyBookingsResponse>)
    | reactQuery.SkipToken;
};

export function hostsGetMyBookingsQuery(
  variables: HostsGetMyBookingsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/hosts/me/bookings",
      operationId: "hostsGetMyBookings",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchHostsGetMyBookings(variables, signal),
  };
}

/**
 * Get all bookings for the current host with optional filtering and sorting
 */
export const useSuspenseHostsGetMyBookings = <
  TData = HostsGetMyBookingsResponse,
>(
  variables: HostsGetMyBookingsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      HostsGetMyBookingsResponse,
      HostsGetMyBookingsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    HostsGetMyBookingsResponse,
    HostsGetMyBookingsError,
    TData
  >({
    ...hostsGetMyBookingsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all bookings for the current host with optional filtering and sorting
 */
export const useHostsGetMyBookings = <TData = HostsGetMyBookingsResponse>(
  variables: HostsGetMyBookingsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      HostsGetMyBookingsResponse,
      HostsGetMyBookingsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<
    HostsGetMyBookingsResponse,
    HostsGetMyBookingsError,
    TData
  >({
    ...hostsGetMyBookingsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type HostsGetBookingByIdPathParams = {
  /**
   * ID of the booking to retrieve
   */
  bookingId: string;
};

export type HostsGetBookingByIdError = Fetcher.ErrorWrapper<undefined>;

export type HostsGetBookingByIdVariables = {
  pathParams: HostsGetBookingByIdPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Get specific booking by ID for current host
 */
export const fetchHostsGetBookingById = (
  variables: HostsGetBookingByIdVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingDTO7,
    HostsGetBookingByIdError,
    undefined,
    {},
    {},
    HostsGetBookingByIdPathParams
  >({
    url: "/api/hosts/me/bookings/{bookingId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get specific booking by ID for current host
 */
export function hostsGetBookingByIdQuery(
  variables: HostsGetBookingByIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.BookingDTO7>;
};

export function hostsGetBookingByIdQuery(
  variables: HostsGetBookingByIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.BookingDTO7>)
    | reactQuery.SkipToken;
};

export function hostsGetBookingByIdQuery(
  variables: HostsGetBookingByIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/hosts/me/bookings/{bookingId}",
      operationId: "hostsGetBookingById",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchHostsGetBookingById(variables, signal),
  };
}

/**
 * Get specific booking by ID for current host
 */
export const useSuspenseHostsGetBookingById = <TData = Schemas.BookingDTO7>(
  variables: HostsGetBookingByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.BookingDTO7,
      HostsGetBookingByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.BookingDTO7,
    HostsGetBookingByIdError,
    TData
  >({
    ...hostsGetBookingByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get specific booking by ID for current host
 */
export const useHostsGetBookingById = <TData = Schemas.BookingDTO7>(
  variables: HostsGetBookingByIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.BookingDTO7,
      HostsGetBookingByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<
    Schemas.BookingDTO7,
    HostsGetBookingByIdError,
    TData
  >({
    ...hostsGetBookingByIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type HostsDeleteBookingPathParams = {
  /**
   * ID of the booking to delete
   */
  bookingId: string;
};

export type HostsDeleteBookingError = Fetcher.ErrorWrapper<undefined>;

export type HostsDeleteBookingVariables = {
  pathParams: HostsDeleteBookingPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Delete(cancel) booking
 */
export const fetchHostsDeleteBooking = (
  variables: HostsDeleteBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingDeletedDTO,
    HostsDeleteBookingError,
    undefined,
    {},
    {},
    HostsDeleteBookingPathParams
  >({
    url: "/api/hosts/me/bookings/{bookingId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete(cancel) booking
 */
export const useHostsDeleteBooking = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BookingDeletedDTO,
      HostsDeleteBookingError,
      HostsDeleteBookingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.BookingDeletedDTO,
    HostsDeleteBookingError,
    HostsDeleteBookingVariables
  >({
    mutationFn: (variables: HostsDeleteBookingVariables) =>
      fetchHostsDeleteBooking(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type HostsUpdateBookingPathParams = {
  /**
   * ID of the booking to update
   */
  bookingId: string;
};

export type HostsUpdateBookingError = Fetcher.ErrorWrapper<undefined>;

export type HostsUpdateBookingVariables = {
  body?: Schemas.UpdateBookingDTO9;
  pathParams: HostsUpdateBookingPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Update booking
 */
export const fetchHostsUpdateBooking = (
  variables: HostsUpdateBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingDeletedDTO,
    HostsUpdateBookingError,
    Schemas.UpdateBookingDTO9,
    {},
    {},
    HostsUpdateBookingPathParams
  >({
    url: "/api/hosts/me/bookings/{bookingId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update booking
 */
export const useHostsUpdateBooking = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BookingDeletedDTO,
      HostsUpdateBookingError,
      HostsUpdateBookingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.BookingDeletedDTO,
    HostsUpdateBookingError,
    HostsUpdateBookingVariables
  >({
    mutationFn: (variables: HostsUpdateBookingVariables) =>
      fetchHostsUpdateBooking(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type HostsGetHostSettingsError = Fetcher.ErrorWrapper<undefined>;

export type HostsGetHostSettingsVariables = BookingContext["fetcherOptions"];

export const fetchHostsGetHostSettings = (
  variables: HostsGetHostSettingsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.HostSettingsDTO,
    HostsGetHostSettingsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/hosts/me/settings", method: "get", ...variables, signal });

export function hostsGetHostSettingsQuery(
  variables: HostsGetHostSettingsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.HostSettingsDTO>;
};

export function hostsGetHostSettingsQuery(
  variables: HostsGetHostSettingsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.HostSettingsDTO>)
    | reactQuery.SkipToken;
};

export function hostsGetHostSettingsQuery(
  variables: HostsGetHostSettingsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/hosts/me/settings",
      operationId: "hostsGetHostSettings",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchHostsGetHostSettings(variables, signal),
  };
}

export const useSuspenseHostsGetHostSettings = <
  TData = Schemas.HostSettingsDTO,
>(
  variables: HostsGetHostSettingsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.HostSettingsDTO,
      HostsGetHostSettingsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.HostSettingsDTO,
    HostsGetHostSettingsError,
    TData
  >({
    ...hostsGetHostSettingsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useHostsGetHostSettings = <TData = Schemas.HostSettingsDTO>(
  variables: HostsGetHostSettingsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.HostSettingsDTO,
      HostsGetHostSettingsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<
    Schemas.HostSettingsDTO,
    HostsGetHostSettingsError,
    TData
  >({
    ...hostsGetHostSettingsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type HostsUpdateSettingsError = Fetcher.ErrorWrapper<undefined>;

export type HostsUpdateSettingsResponse = {
  /**
   * status
   */
  status?: string;
};

export type HostsUpdateSettingsVariables = {
  body?: Schemas.UpdateHostSettingsDTO;
} & BookingContext["fetcherOptions"];

export const fetchHostsUpdateSettings = (
  variables: HostsUpdateSettingsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    HostsUpdateSettingsResponse,
    HostsUpdateSettingsError,
    Schemas.UpdateHostSettingsDTO,
    {},
    {},
    {}
  >({ url: "/api/hosts/me/settings", method: "patch", ...variables, signal });

export const useHostsUpdateSettings = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      HostsUpdateSettingsResponse,
      HostsUpdateSettingsError,
      HostsUpdateSettingsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    HostsUpdateSettingsResponse,
    HostsUpdateSettingsError,
    HostsUpdateSettingsVariables
  >({
    mutationFn: (variables: HostsUpdateSettingsVariables) =>
      fetchHostsUpdateSettings(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AdminGetClientsError = Fetcher.ErrorWrapper<undefined>;

export type AdminGetClientsResponse = Schemas.ClientDTO[];

export type AdminGetClientsVariables = BookingContext["fetcherOptions"];

/**
 * Allows you to get all the clients created in the system
 */
export const fetchAdminGetClients = (
  variables: AdminGetClientsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    AdminGetClientsResponse,
    AdminGetClientsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/admin/clients", method: "get", ...variables, signal });

/**
 * Allows you to get all the clients created in the system
 */
export function adminGetClientsQuery(variables: AdminGetClientsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<AdminGetClientsResponse>;
};

export function adminGetClientsQuery(
  variables: AdminGetClientsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<AdminGetClientsResponse>)
    | reactQuery.SkipToken;
};

export function adminGetClientsQuery(
  variables: AdminGetClientsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/admin/clients",
      operationId: "adminGetClients",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchAdminGetClients(variables, signal),
  };
}

/**
 * Allows you to get all the clients created in the system
 */
export const useSuspenseAdminGetClients = <TData = AdminGetClientsResponse>(
  variables: AdminGetClientsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      AdminGetClientsResponse,
      AdminGetClientsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    AdminGetClientsResponse,
    AdminGetClientsError,
    TData
  >({
    ...adminGetClientsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Allows you to get all the clients created in the system
 */
export const useAdminGetClients = <TData = AdminGetClientsResponse>(
  variables: AdminGetClientsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      AdminGetClientsResponse,
      AdminGetClientsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<
    AdminGetClientsResponse,
    AdminGetClientsError,
    TData
  >({
    ...adminGetClientsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AdminCreateNewClientError = Fetcher.ErrorWrapper<undefined>;

export type AdminCreateNewClientVariables = {
  body: Schemas.CreateClientDTO;
} & BookingContext["fetcherOptions"];

/**
 * Allows you to create a new client
 */
export const fetchAdminCreateNewClient = (
  variables: AdminCreateNewClientVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UserCreatedDTO,
    AdminCreateNewClientError,
    Schemas.CreateClientDTO,
    {},
    {},
    {}
  >({ url: "/api/admin/clients", method: "post", ...variables, signal });

/**
 * Allows you to create a new client
 */
export const useAdminCreateNewClient = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserCreatedDTO,
      AdminCreateNewClientError,
      AdminCreateNewClientVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.UserCreatedDTO,
    AdminCreateNewClientError,
    AdminCreateNewClientVariables
  >({
    mutationFn: (variables: AdminCreateNewClientVariables) =>
      fetchAdminCreateNewClient(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AdminGetClientByIdPathParams = {
  clientId: string;
};

export type AdminGetClientByIdError = Fetcher.ErrorWrapper<undefined>;

export type AdminGetClientByIdVariables = {
  pathParams: AdminGetClientByIdPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Allows you to get a specific client by his id
 */
export const fetchAdminGetClientById = (
  variables: AdminGetClientByIdVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.ClientDTO,
    AdminGetClientByIdError,
    undefined,
    {},
    {},
    AdminGetClientByIdPathParams
  >({
    url: "/api/admin/clients/{clientId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Allows you to get a specific client by his id
 */
export function adminGetClientByIdQuery(
  variables: AdminGetClientByIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ClientDTO>;
};

export function adminGetClientByIdQuery(
  variables: AdminGetClientByIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ClientDTO>)
    | reactQuery.SkipToken;
};

export function adminGetClientByIdQuery(
  variables: AdminGetClientByIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/admin/clients/{clientId}",
      operationId: "adminGetClientById",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchAdminGetClientById(variables, signal),
  };
}

/**
 * Allows you to get a specific client by his id
 */
export const useSuspenseAdminGetClientById = <TData = Schemas.ClientDTO>(
  variables: AdminGetClientByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ClientDTO,
      AdminGetClientByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.ClientDTO,
    AdminGetClientByIdError,
    TData
  >({
    ...adminGetClientByIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Allows you to get a specific client by his id
 */
export const useAdminGetClientById = <TData = Schemas.ClientDTO>(
  variables: AdminGetClientByIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ClientDTO,
      AdminGetClientByIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<Schemas.ClientDTO, AdminGetClientByIdError, TData>(
    {
      ...adminGetClientByIdQuery(
        variables === reactQuery.skipToken
          ? variables
          : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    },
  );
};

export type AdminUpdateClietnPathParams = {
  clientId: string;
};

export type AdminUpdateClietnError = Fetcher.ErrorWrapper<undefined>;

export type AdminUpdateClietnVariables = {
  body?: Schemas.UpdateClientDTO5;
  pathParams: AdminUpdateClietnPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Allows you to update the client
 */
export const fetchAdminUpdateClietn = (
  variables: AdminUpdateClietnVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UserUpdatedDTO,
    AdminUpdateClietnError,
    Schemas.UpdateClientDTO5,
    {},
    {},
    AdminUpdateClietnPathParams
  >({
    url: "/api/admin/clients/{clientId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Allows you to update the client
 */
export const useAdminUpdateClietn = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserUpdatedDTO,
      AdminUpdateClietnError,
      AdminUpdateClietnVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.UserUpdatedDTO,
    AdminUpdateClietnError,
    AdminUpdateClietnVariables
  >({
    mutationFn: (variables: AdminUpdateClietnVariables) =>
      fetchAdminUpdateClietn(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AdminDeleteClientPathParams = {
  clientId: string;
};

export type AdminDeleteClientError = Fetcher.ErrorWrapper<undefined>;

export type AdminDeleteClientVariables = {
  pathParams: AdminDeleteClientPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Allows you to delete a client
 */
export const fetchAdminDeleteClient = (
  variables: AdminDeleteClientVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UsedDeletedDTO,
    AdminDeleteClientError,
    {},
    {},
    {},
    AdminDeleteClientPathParams
  >({
    url: "/api/admin/clients/{clientId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Allows you to delete a client
 */
export const useAdminDeleteClient = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UsedDeletedDTO,
      AdminDeleteClientError,
      AdminDeleteClientVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.UsedDeletedDTO,
    AdminDeleteClientError,
    AdminDeleteClientVariables
  >({
    mutationFn: (variables: AdminDeleteClientVariables) =>
      fetchAdminDeleteClient(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AdminGetHostsError = Fetcher.ErrorWrapper<undefined>;

export type AdminGetHostsResponse = Schemas.HostDTO[];

export type AdminGetHostsVariables = BookingContext["fetcherOptions"];

/**
 * Allows you to get all the hosts
 */
export const fetchAdminGetHosts = (
  variables: AdminGetHostsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    AdminGetHostsResponse,
    AdminGetHostsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/admin/hosts", method: "get", ...variables, signal });

/**
 * Allows you to get all the hosts
 */
export function adminGetHostsQuery(variables: AdminGetHostsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<AdminGetHostsResponse>;
};

export function adminGetHostsQuery(
  variables: AdminGetHostsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<AdminGetHostsResponse>)
    | reactQuery.SkipToken;
};

export function adminGetHostsQuery(
  variables: AdminGetHostsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/admin/hosts",
      operationId: "adminGetHosts",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchAdminGetHosts(variables, signal),
  };
}

/**
 * Allows you to get all the hosts
 */
export const useSuspenseAdminGetHosts = <TData = AdminGetHostsResponse>(
  variables: AdminGetHostsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      AdminGetHostsResponse,
      AdminGetHostsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    AdminGetHostsResponse,
    AdminGetHostsError,
    TData
  >({
    ...adminGetHostsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Allows you to get all the hosts
 */
export const useAdminGetHosts = <TData = AdminGetHostsResponse>(
  variables: AdminGetHostsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      AdminGetHostsResponse,
      AdminGetHostsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<AdminGetHostsResponse, AdminGetHostsError, TData>({
    ...adminGetHostsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AdminCreateNewHostError = Fetcher.ErrorWrapper<undefined>;

export type AdminCreateNewHostVariables = {
  body: Schemas.CreateHostDTO;
} & BookingContext["fetcherOptions"];

/**
 * Allows you to create a new host
 */
export const fetchAdminCreateNewHost = (
  variables: AdminCreateNewHostVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UserCreatedDTO,
    AdminCreateNewHostError,
    Schemas.CreateHostDTO,
    {},
    {},
    {}
  >({ url: "/api/admin/hosts", method: "post", ...variables, signal });

/**
 * Allows you to create a new host
 */
export const useAdminCreateNewHost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserCreatedDTO,
      AdminCreateNewHostError,
      AdminCreateNewHostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.UserCreatedDTO,
    AdminCreateNewHostError,
    AdminCreateNewHostVariables
  >({
    mutationFn: (variables: AdminCreateNewHostVariables) =>
      fetchAdminCreateNewHost(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AdminGetHostPathParams = {
  hostId: string;
};

export type AdminGetHostError = Fetcher.ErrorWrapper<undefined>;

export type AdminGetHostVariables = {
  pathParams: AdminGetHostPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Allows you to get a host by its Id
 */
export const fetchAdminGetHost = (
  variables: AdminGetHostVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.HostDTO,
    AdminGetHostError,
    undefined,
    {},
    {},
    AdminGetHostPathParams
  >({ url: "/api/admin/hosts/{hostId}", method: "get", ...variables, signal });

/**
 * Allows you to get a host by its Id
 */
export function adminGetHostQuery(variables: AdminGetHostVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.HostDTO>;
};

export function adminGetHostQuery(
  variables: AdminGetHostVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.HostDTO>)
    | reactQuery.SkipToken;
};

export function adminGetHostQuery(
  variables: AdminGetHostVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/admin/hosts/{hostId}",
      operationId: "adminGetHost",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchAdminGetHost(variables, signal),
  };
}

/**
 * Allows you to get a host by its Id
 */
export const useSuspenseAdminGetHost = <TData = Schemas.HostDTO>(
  variables: AdminGetHostVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.HostDTO, AdminGetHostError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<Schemas.HostDTO, AdminGetHostError, TData>(
    {
      ...adminGetHostQuery(deepMerge(fetcherOptions, variables)),
      ...options,
      ...queryOptions,
    },
  );
};

/**
 * Allows you to get a host by its Id
 */
export const useAdminGetHost = <TData = Schemas.HostDTO>(
  variables: AdminGetHostVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.HostDTO, AdminGetHostError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<Schemas.HostDTO, AdminGetHostError, TData>({
    ...adminGetHostQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AdminUpdateHostPathParams = {
  hostId: string;
};

export type AdminUpdateHostError = Fetcher.ErrorWrapper<undefined>;

export type AdminUpdateHostVariables = {
  body?: Schemas.UpdateHostDTO10;
  pathParams: AdminUpdateHostPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Allows you to update the host
 */
export const fetchAdminUpdateHost = (
  variables: AdminUpdateHostVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UserUpdatedDTO,
    AdminUpdateHostError,
    Schemas.UpdateHostDTO10,
    {},
    {},
    AdminUpdateHostPathParams
  >({
    url: "/api/admin/hosts/{hostId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Allows you to update the host
 */
export const useAdminUpdateHost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserUpdatedDTO,
      AdminUpdateHostError,
      AdminUpdateHostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.UserUpdatedDTO,
    AdminUpdateHostError,
    AdminUpdateHostVariables
  >({
    mutationFn: (variables: AdminUpdateHostVariables) =>
      fetchAdminUpdateHost(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AdminDeleteHostPathParams = {
  hostId: string;
};

export type AdminDeleteHostError = Fetcher.ErrorWrapper<undefined>;

export type AdminDeleteHostVariables = {
  pathParams: AdminDeleteHostPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Allows you to delete a host
 */
export const fetchAdminDeleteHost = (
  variables: AdminDeleteHostVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UsedDeletedDTO,
    AdminDeleteHostError,
    undefined,
    {},
    {},
    AdminDeleteHostPathParams
  >({
    url: "/api/admin/hosts/{hostId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Allows you to delete a host
 */
export const useAdminDeleteHost = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UsedDeletedDTO,
      AdminDeleteHostError,
      AdminDeleteHostVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.UsedDeletedDTO,
    AdminDeleteHostError,
    AdminDeleteHostVariables
  >({
    mutationFn: (variables: AdminDeleteHostVariables) =>
      fetchAdminDeleteHost(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AdminGetBookingsError = Fetcher.ErrorWrapper<undefined>;

export type AdminGetBookingsResponse = Schemas.BookingDTO[];

export type AdminGetBookingsVariables = BookingContext["fetcherOptions"];

/**
 * Allows you to get all the booklets created in the system
 */
export const fetchAdminGetBookings = (
  variables: AdminGetBookingsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    AdminGetBookingsResponse,
    AdminGetBookingsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/admin/bookings", method: "get", ...variables, signal });

/**
 * Allows you to get all the booklets created in the system
 */
export function adminGetBookingsQuery(variables: AdminGetBookingsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<AdminGetBookingsResponse>;
};

export function adminGetBookingsQuery(
  variables: AdminGetBookingsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<AdminGetBookingsResponse>)
    | reactQuery.SkipToken;
};

export function adminGetBookingsQuery(
  variables: AdminGetBookingsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/admin/bookings",
      operationId: "adminGetBookings",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchAdminGetBookings(variables, signal),
  };
}

/**
 * Allows you to get all the booklets created in the system
 */
export const useSuspenseAdminGetBookings = <TData = AdminGetBookingsResponse>(
  variables: AdminGetBookingsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      AdminGetBookingsResponse,
      AdminGetBookingsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    AdminGetBookingsResponse,
    AdminGetBookingsError,
    TData
  >({
    ...adminGetBookingsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Allows you to get all the booklets created in the system
 */
export const useAdminGetBookings = <TData = AdminGetBookingsResponse>(
  variables: AdminGetBookingsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      AdminGetBookingsResponse,
      AdminGetBookingsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<
    AdminGetBookingsResponse,
    AdminGetBookingsError,
    TData
  >({
    ...adminGetBookingsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AdminCreateNewBookingError = Fetcher.ErrorWrapper<undefined>;

export type AdminCreateNewBookingVariables = {
  body: Schemas.CreateBookingDTO;
} & BookingContext["fetcherOptions"];

/**
 * Allow create a new booking
 */
export const fetchAdminCreateNewBooking = (
  variables: AdminCreateNewBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingCreatedDTO,
    AdminCreateNewBookingError,
    Schemas.CreateBookingDTO,
    {},
    {},
    {}
  >({ url: "/api/admin/bookings", method: "post", ...variables, signal });

/**
 * Allow create a new booking
 */
export const useAdminCreateNewBooking = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BookingCreatedDTO,
      AdminCreateNewBookingError,
      AdminCreateNewBookingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.BookingCreatedDTO,
    AdminCreateNewBookingError,
    AdminCreateNewBookingVariables
  >({
    mutationFn: (variables: AdminCreateNewBookingVariables) =>
      fetchAdminCreateNewBooking(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AdminGetBookingPathParams = {
  bookingId: string;
};

export type AdminGetBookingError = Fetcher.ErrorWrapper<undefined>;

export type AdminGetBookingVariables = {
  pathParams: AdminGetBookingPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Get a booking by his Id
 */
export const fetchAdminGetBooking = (
  variables: AdminGetBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingDTO,
    AdminGetBookingError,
    undefined,
    {},
    {},
    AdminGetBookingPathParams
  >({
    url: "/api/admin/bookings/{bookingId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a booking by his Id
 */
export function adminGetBookingQuery(variables: AdminGetBookingVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.BookingDTO>;
};

export function adminGetBookingQuery(
  variables: AdminGetBookingVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.BookingDTO>)
    | reactQuery.SkipToken;
};

export function adminGetBookingQuery(
  variables: AdminGetBookingVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/admin/bookings/{bookingId}",
      operationId: "adminGetBooking",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchAdminGetBooking(variables, signal),
  };
}

/**
 * Get a booking by his Id
 */
export const useSuspenseAdminGetBooking = <TData = Schemas.BookingDTO>(
  variables: AdminGetBookingVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.BookingDTO, AdminGetBookingError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.BookingDTO,
    AdminGetBookingError,
    TData
  >({
    ...adminGetBookingQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a booking by his Id
 */
export const useAdminGetBooking = <TData = Schemas.BookingDTO>(
  variables: AdminGetBookingVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.BookingDTO, AdminGetBookingError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useBookingContext(options);
  return reactQuery.useQuery<Schemas.BookingDTO, AdminGetBookingError, TData>({
    ...adminGetBookingQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AdminUpdateBookingPathParams = {
  bookingId: string;
};

export type AdminUpdateBookingError = Fetcher.ErrorWrapper<undefined>;

export type AdminUpdateBookingVariables = {
  body?: Schemas.UpdateBookingDTO;
  pathParams: AdminUpdateBookingPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Allows you to update the booking by its id
 */
export const fetchAdminUpdateBooking = (
  variables: AdminUpdateBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingUpdatedDTO,
    AdminUpdateBookingError,
    Schemas.UpdateBookingDTO,
    {},
    {},
    AdminUpdateBookingPathParams
  >({
    url: "/api/admin/bookings/{bookingId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Allows you to update the booking by its id
 */
export const useAdminUpdateBooking = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BookingUpdatedDTO,
      AdminUpdateBookingError,
      AdminUpdateBookingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.BookingUpdatedDTO,
    AdminUpdateBookingError,
    AdminUpdateBookingVariables
  >({
    mutationFn: (variables: AdminUpdateBookingVariables) =>
      fetchAdminUpdateBooking(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type AdminDeleteBookingPathParams = {
  bookingId: string;
};

export type AdminDeleteBookingError = Fetcher.ErrorWrapper<undefined>;

export type AdminDeleteBookingVariables = {
  pathParams: AdminDeleteBookingPathParams;
} & BookingContext["fetcherOptions"];

/**
 * Allows you to delete a booking by its Id
 */
export const fetchAdminDeleteBooking = (
  variables: AdminDeleteBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingDeletedDTO,
    AdminDeleteBookingError,
    undefined,
    {},
    {},
    AdminDeleteBookingPathParams
  >({
    url: "/api/admin/bookings/{bookingId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Allows you to delete a booking by its Id
 */
export const useAdminDeleteBooking = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BookingDeletedDTO,
      AdminDeleteBookingError,
      AdminDeleteBookingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useBookingContext();
  return reactQuery.useMutation<
    Schemas.BookingDeletedDTO,
    AdminDeleteBookingError,
    AdminDeleteBookingVariables
  >({
    mutationFn: (variables: AdminDeleteBookingVariables) =>
      fetchAdminDeleteBooking(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: "/api//hosts";
      operationId: "publicGetHosts";
      variables: PublicGetHostsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/hosts/{id}";
      operationId: "publicGetHostById";
      variables: PublicGetHostByIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/hosts/{id}/bookings";
      operationId: "publicGetHostBookings";
      variables: PublicGetHostBookingsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/clients/me";
      operationId: "clientsGetClient";
      variables: ClientsGetClientVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/clients/me/bookings";
      operationId: "clientsGetBookings";
      variables: ClientsGetBookingsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/clients/me/bookings/{bookingId}";
      operationId: "clientsGetBookingById";
      variables: ClientsGetBookingByIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/hosts/me";
      operationId: "hostsGetMe";
      variables: HostsGetMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/hosts/me/bookings";
      operationId: "hostsGetMyBookings";
      variables: HostsGetMyBookingsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/hosts/me/bookings/{bookingId}";
      operationId: "hostsGetBookingById";
      variables: HostsGetBookingByIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/hosts/me/settings";
      operationId: "hostsGetHostSettings";
      variables: HostsGetHostSettingsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/admin/clients";
      operationId: "adminGetClients";
      variables: AdminGetClientsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/admin/clients/{clientId}";
      operationId: "adminGetClientById";
      variables: AdminGetClientByIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/admin/hosts";
      operationId: "adminGetHosts";
      variables: AdminGetHostsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/admin/hosts/{hostId}";
      operationId: "adminGetHost";
      variables: AdminGetHostVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/admin/bookings";
      operationId: "adminGetBookings";
      variables: AdminGetBookingsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/admin/bookings/{bookingId}";
      operationId: "adminGetBooking";
      variables: AdminGetBookingVariables | reactQuery.SkipToken;
    };
