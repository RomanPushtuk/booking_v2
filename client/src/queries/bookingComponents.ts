/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import type * as Fetcher from "./bookingFetcher";
import { bookingFetch } from "./bookingFetcher";
import type * as Schemas from "./bookingSchemas";

export type PublicGetHostsError = Fetcher.ErrorWrapper<undefined>;

export type PublicGetHostsResponse = Schemas.HostDTO[];

/**
 * Get list of all available hosts
 */
export const publicGetHosts = (signal?: AbortSignal) =>
  bookingFetch<
    PublicGetHostsResponse,
    PublicGetHostsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/hosts", method: "get", signal });

export type PublicGetHostByIdPathParams = {
  id: string;
};

export type PublicGetHostByIdError = Fetcher.ErrorWrapper<undefined>;

export type PublicGetHostByIdVariables = {
  pathParams: PublicGetHostByIdPathParams;
};

/**
 * Each user of the system can get information about the host
 */
export const publicGetHostById = (
  variables: PublicGetHostByIdVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.HostDTO,
    PublicGetHostByIdError,
    undefined,
    {},
    {},
    PublicGetHostByIdPathParams
  >({ url: "/hosts/{id}", method: "get", ...variables, signal });

export type PublicGetHostBookingsPathParams = {
  /**
   * Host ID
   */
  id: string;
};

export type PublicGetHostBookingsQueryParams = {
  /**
   * Sort direction for bookings
   *
   * @default ASC
   */
  sortDirection?: "DESC" | "ASC";
};

export type PublicGetHostBookingsError = Fetcher.ErrorWrapper<undefined>;

export type PublicGetHostBookingsResponse = Schemas.BookingDTO7[];

export type PublicGetHostBookingsVariables = {
  pathParams: PublicGetHostBookingsPathParams;
  queryParams?: PublicGetHostBookingsQueryParams;
};

/**
 * Get host's bookings from now until the host's forward booking period. Shows occupied time slots for planning appointments.
 */
export const publicGetHostBookings = (
  variables: PublicGetHostBookingsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    PublicGetHostBookingsResponse,
    PublicGetHostBookingsError,
    undefined,
    {},
    PublicGetHostBookingsQueryParams,
    PublicGetHostBookingsPathParams
  >({ url: "/hosts/{id}/bookings", method: "get", ...variables, signal });

export type AuthRegisterError = Fetcher.ErrorWrapper<undefined>;

export type AuthRegisterVariables = {
  body: Schemas.CreateUserDTO;
};

/**
 * Registering a new user in the system
 */
export const authRegister = (
  variables: AuthRegisterVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UserCreatedDTO,
    AuthRegisterError,
    Schemas.CreateUserDTO,
    {},
    {},
    {}
  >({ url: "/auth/register", method: "post", ...variables, signal });

export type AuthLoginError = Fetcher.ErrorWrapper<{
  status: 401;
  payload: {
    /**
     * @example Invalid login or password
     */
    error?: string;
  };
}>;

export type AuthLoginVariables = {
  body: Schemas.AuthUserDTO;
};

/**
 * Authenticate user and receive JWT token.
 *
 * **Important**: When using the returned token in other endpoints:
 * - Copy the `access_token` from the response
 * - Use it directly in the Authorization field (do not add 'Bearer ' prefix)
 * - Example: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...`
 */
export const authLogin = (
  variables: AuthLoginVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.UserAuthorizedDTO,
    AuthLoginError,
    Schemas.AuthUserDTO,
    {},
    {},
    {}
  >({ url: "/auth/login", method: "post", ...variables, signal });

export type ClientsGetClientError = Fetcher.ErrorWrapper<
  | {
      status: 401;
      payload: {
        /**
         * @example Unauthorized
         */
        error?: string;
      };
    }
  | {
      status: 403;
      payload: {
        /**
         * @example Access denied
         */
        error?: string;
      };
    }
>;

/**
 * Get current client information
 */
export const clientsGetClient = (signal?: AbortSignal) =>
  bookingFetch<Schemas.ClientDTO, ClientsGetClientError, undefined, {}, {}, {}>(
    { url: "/clients/me", method: "get", signal },
  );

export type ClientsUpdateClientError = Fetcher.ErrorWrapper<undefined>;

export type ClientsUpdateClientVariables = {
  body?: Schemas.UpdateClientDTO;
};

/**
 * Update current client information
 */
export const clientsUpdateClient = (
  variables: ClientsUpdateClientVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.ClientUpdatedDTO,
    ClientsUpdateClientError,
    Schemas.UpdateClientDTO,
    {},
    {},
    {}
  >({ url: "/clients/me", method: "patch", ...variables, signal });

export type ClientsDeleteClientError = Fetcher.ErrorWrapper<undefined>;

/**
 * Mark current client as deleted from the system
 */
export const clientsDeleteClient = (signal?: AbortSignal) =>
  bookingFetch<
    Schemas.ClientDeletedDTO,
    ClientsDeleteClientError,
    undefined,
    {},
    {},
    {}
  >({ url: "/clients/me", method: "delete", signal });

export type ClientsGetBookingsQueryParams = {
  /**
   * Sort direction for results
   *
   * @default ASC
   */
  sortDirection?: "ASC" | "DESC";
  /**
   * Property to sort by
   *
   * @default fromDateTime
   */
  sortProperty?: string;
  /**
   * Filter bookings that start after this time (ISO8601).
   *
   * @format date-time
   */
  fromDateTime?: string;
  /**
   * Filter bookings that end before this time (ISO8601).
   *
   * @format date-time
   */
  toDateTime?: string;
};

export type ClientsGetBookingsError = Fetcher.ErrorWrapper<undefined>;

export type ClientsGetBookingsResponse = Schemas.BookingDTO[];

export type ClientsGetBookingsVariables = {
  queryParams?: ClientsGetBookingsQueryParams;
};

/**
 * Get current client's bookings with filtering and sorting
 */
export const clientsGetBookings = (
  variables: ClientsGetBookingsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    ClientsGetBookingsResponse,
    ClientsGetBookingsError,
    undefined,
    {},
    ClientsGetBookingsQueryParams,
    {}
  >({ url: "/clients/me/bookings", method: "get", ...variables, signal });

export type ClientsCreateBookingError = Fetcher.ErrorWrapper<undefined>;

export type ClientsCreateBookingVariables = {
  body: Schemas.CreateClientBookingDTO;
};

/**
 * Create a new booking for current client
 */
export const clientsCreateBooking = (
  variables: ClientsCreateBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingCreatedDTO,
    ClientsCreateBookingError,
    Schemas.CreateClientBookingDTO,
    {},
    {},
    {}
  >({ url: "/clients/me/bookings", method: "post", ...variables, signal });

export type ClientsGetBookingByIdPathParams = {
  /**
   * ID of the booking to retrieve
   */
  bookingId: string;
};

export type ClientsGetBookingByIdError = Fetcher.ErrorWrapper<undefined>;

export type ClientsGetBookingByIdVariables = {
  pathParams: ClientsGetBookingByIdPathParams;
};

/**
 * Get specific booking by ID for current client
 */
export const clientsGetBookingById = (
  variables: ClientsGetBookingByIdVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingDTO,
    ClientsGetBookingByIdError,
    undefined,
    {},
    {},
    ClientsGetBookingByIdPathParams
  >({
    url: "/clients/me/bookings/{bookingId}",
    method: "get",
    ...variables,
    signal,
  });

export type ClientsUpdateBookingPathParams = {
  /**
   * ID of the booking to update
   */
  bookingId: string;
};

export type ClientsUpdateBookingError = Fetcher.ErrorWrapper<undefined>;

export type ClientsUpdateBookingVariables = {
  body?: Schemas.UpdateClientBookingDTO;
  pathParams: ClientsUpdateBookingPathParams;
};

/**
 * Update specific booking for current client
 */
export const clientsUpdateBooking = (
  variables: ClientsUpdateBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingUpdatedDTO,
    ClientsUpdateBookingError,
    Schemas.UpdateClientBookingDTO,
    {},
    {},
    ClientsUpdateBookingPathParams
  >({
    url: "/clients/me/bookings/{bookingId}",
    method: "patch",
    ...variables,
    signal,
  });

export type ClientsCancelBookingPathParams = {
  /**
   * ID of the booking to cancel
   */
  bookingId: string;
};

export type ClientsCancelBookingError = Fetcher.ErrorWrapper<undefined>;

export type ClientsCancelBookingVariables = {
  pathParams: ClientsCancelBookingPathParams;
};

/**
 * Cancel (soft delete) specific booking for current client
 */
export const clientsCancelBooking = (
  variables: ClientsCancelBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingDeletedDTO,
    ClientsCancelBookingError,
    undefined,
    {},
    {},
    ClientsCancelBookingPathParams
  >({
    url: "/clients/me/bookings/{bookingId}",
    method: "delete",
    ...variables,
    signal,
  });

export type HostsGetMeError = Fetcher.ErrorWrapper<undefined>;

/**
 * Get information about the current host
 */
export const hostsGetMe = (signal?: AbortSignal) =>
  bookingFetch<Schemas.HostDTO, HostsGetMeError, undefined, {}, {}, {}>({
    url: "/hosts/me",
    method: "get",
    signal,
  });

export type HostsDeleteMeError = Fetcher.ErrorWrapper<undefined>;

/**
 * Mark host as deleted
 */
export const hostsDeleteMe = (signal?: AbortSignal) =>
  bookingFetch<
    Schemas.HostDeletedDTO,
    HostsDeleteMeError,
    undefined,
    {},
    {},
    {}
  >({ url: "/hosts/me", method: "delete", signal });

export type HostsUpdateMeError = Fetcher.ErrorWrapper<undefined>;

export type HostsUpdateMeVariables = {
  body?: Schemas.UpdateHostDTO;
};

/**
 * Update host params
 */
export const hostsUpdateMe = (
  variables: HostsUpdateMeVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.HostUpdatedDTO,
    HostsUpdateMeError,
    Schemas.UpdateHostDTO,
    {},
    {},
    {}
  >({ url: "/hosts/me", method: "patch", ...variables, signal });

export type HostsCreateBookingError = Fetcher.ErrorWrapper<undefined>;

export type HostsCreateBookingVariables = {
  body: Schemas.CreateBookingDTO3;
};

/**
 * Create a new booking as a host (administrative function).
 *
 * **Important:** The hostId in the request body will be IGNORED and automatically
 * set to the current authenticated user's ID. This is an administrative endpoint
 * where hosts create bookings for their clients.
 *
 * **Use cases:**
 * - Medical receptionist booking patient appointments
 * - Service provider scheduling client meetings
 * - Host creating appointments for existing clients
 *
 * **Note:** The hostId field is required in the request body for DTO validation,
 * but its value is overridden by the current user's ID in the implementation.
 */
export const hostsCreateBooking = (
  variables: HostsCreateBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingCreatedDTO4,
    HostsCreateBookingError,
    Schemas.CreateBookingDTO3,
    {},
    {},
    {}
  >({ url: "/hosts/me/bookings", method: "post", ...variables, signal });

export type HostsGetMyBookingsQueryParams = {
  /**
   * Filter by client ID
   */
  clientId?: string;
  /**
   * Sort direction
   *
   * @default DESC
   */
  sortDirection?: "DESC" | "ASC";
  /**
   * Property to sort by
   *
   * @default fromDateTime
   */
  sortProperty?: "fromDateTime" | "toDateTime";
  /**
   * Filter bookings from this date-time (ISO8601)
   *
   * @format date-time
   */
  fromDateTime?: string;
  /**
   * Filter bookings until this date-time (ISO8601)
   *
   * @format date-time
   */
  toDateTime?: string;
};

export type HostsGetMyBookingsError = Fetcher.ErrorWrapper<undefined>;

export type HostsGetMyBookingsResponse = Schemas.BookingDTO1[];

export type HostsGetMyBookingsVariables = {
  queryParams?: HostsGetMyBookingsQueryParams;
};

/**
 * Get all bookings for the current host with optional filtering and sorting
 */
export const hostsGetMyBookings = (
  variables: HostsGetMyBookingsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    HostsGetMyBookingsResponse,
    HostsGetMyBookingsError,
    undefined,
    {},
    HostsGetMyBookingsQueryParams,
    {}
  >({ url: "/hosts/me/bookings", method: "get", ...variables, signal });

export type HostsGetBookingByIdPathParams = {
  /**
   * ID of the booking to retrieve
   */
  bookingId: string;
};

export type HostsGetBookingByIdError = Fetcher.ErrorWrapper<undefined>;

export type HostsGetBookingByIdVariables = {
  pathParams: HostsGetBookingByIdPathParams;
};

/**
 * Get specific booking by ID for current host
 */
export const hostsGetBookingById = (
  variables: HostsGetBookingByIdVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingDTO1,
    HostsGetBookingByIdError,
    undefined,
    {},
    {},
    HostsGetBookingByIdPathParams
  >({
    url: "/hosts/me/bookings/{bookingId}",
    method: "get",
    ...variables,
    signal,
  });

export type HostsDeleteBookingPathParams = {
  /**
   * ID of the booking to delete
   */
  bookingId: string;
};

export type HostsDeleteBookingError = Fetcher.ErrorWrapper<undefined>;

export type HostsDeleteBookingVariables = {
  pathParams: HostsDeleteBookingPathParams;
};

/**
 * Delete(cancel) booking
 */
export const hostsDeleteBooking = (
  variables: HostsDeleteBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingDeletedDTO2,
    HostsDeleteBookingError,
    undefined,
    {},
    {},
    HostsDeleteBookingPathParams
  >({
    url: "/hosts/me/bookings/{bookingId}",
    method: "delete",
    ...variables,
    signal,
  });

export type HostsUpdateBookingPathParams = {
  /**
   * ID of the booking to update
   */
  bookingId: string;
};

export type HostsUpdateBookingError = Fetcher.ErrorWrapper<undefined>;

export type HostsUpdateBookingVariables = {
  body?: Schemas.UpdateBookingDTO;
  pathParams: HostsUpdateBookingPathParams;
};

/**
 * Update booking
 */
export const hostsUpdateBooking = (
  variables: HostsUpdateBookingVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    Schemas.BookingUpdatedDTO3,
    HostsUpdateBookingError,
    Schemas.UpdateBookingDTO,
    {},
    {},
    HostsUpdateBookingPathParams
  >({
    url: "/hosts/me/bookings/{bookingId}",
    method: "patch",
    ...variables,
    signal,
  });

export type HostsGetHostSettingsError = Fetcher.ErrorWrapper<undefined>;

export const hostsGetHostSettings = (signal?: AbortSignal) =>
  bookingFetch<
    Schemas.HostSettingsDTO,
    HostsGetHostSettingsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/hosts/me/settings", method: "get", signal });

export type HostsUpdateSettingsError = Fetcher.ErrorWrapper<undefined>;

export type HostsUpdateSettingsResponse = {
  /**
   * status
   */
  status?: string;
};

export type HostsUpdateSettingsVariables = {
  body?: Schemas.UpdateHostSettingsDTO;
};

export const hostsUpdateSettings = (
  variables: HostsUpdateSettingsVariables,
  signal?: AbortSignal,
) =>
  bookingFetch<
    HostsUpdateSettingsResponse,
    HostsUpdateSettingsError,
    Schemas.UpdateHostSettingsDTO,
    {},
    {},
    {}
  >({ url: "/hosts/me/settings", method: "patch", ...variables, signal });

export const operationsByTag = {
  public: { publicGetHosts, publicGetHostById, publicGetHostBookings },
  auth: { authRegister, authLogin },
  clients: {
    clientsGetClient,
    clientsUpdateClient,
    clientsDeleteClient,
    clientsGetBookings,
    clientsCreateBooking,
    clientsGetBookingById,
    clientsUpdateBooking,
    clientsCancelBooking,
  },
  hosts: {
    hostsGetMe,
    hostsDeleteMe,
    hostsUpdateMe,
    hostsCreateBooking,
    hostsGetMyBookings,
    hostsGetBookingById,
    hostsDeleteBooking,
    hostsUpdateBooking,
    hostsGetHostSettings,
    hostsUpdateSettings,
  },
};
